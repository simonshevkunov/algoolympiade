---
layout: default
---

<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$']]
    }
  };
</script>

### [Алгоритмы](index.md) / Динамическое программирование

# **Динамическое программирование**

Нередко на олимпиадах встречаются задачи, провоцирующие использовать алгоритмы перебора. Но простой перебор может быть неоптимален, поэтому для решения таких задач используется метод *динамического программирования*. Этот метод заключается в разбиении сложной задачи на менее сложные подзадачи. Предполагается, что у нас есть таблица, куда мы запоминаем решения подзадач, при том, что нам известны самые начальные значения (например, нулевой элемент в таблице). 

Самый яркий способ демонстрации работы метода динамического программирования – поиск $N$-ого числа в ряду Фибоначчи по заданному $N$. 

Для справки: любое число в последовательности Фибоначчи – сумма двух предыдущих ему чисел в последовательности. Первые два числа ряда – единицы. 

Перед написанием кода выведем формулу нахождения $N$-ого числа Фибоначчи. Нетрудно понять, что $F_n = F_{N - 1} + F_{N – 2}$. 

Таким образом решение можно представить в виде таблицы, где $i$-той ячейке преписывается решение задачи, в которой $N = i$.

| $N$ | 1 | 2 | 3 | 4 | 5 | 6 | ... |
|-----|---|---|---|---|---|---|-----|
| $F_n$ | 1 | 1 | 2 | 3 | 5 | 8 | ... |

Теперь мы можем записать это решение несложной рекурсией. Чтобы реализовать действие метода, нужно создать таблицу. Роль таблицы в данном случае сыграет словарь, его необходимо завести как глобальную переменную (вне функции): 

```py
    memory = {}
```

Чтобы рекурсия не ушла в бесконечность, мы занесем в словарь изначально известные значения первых двух чисел Фибоначчи – эти значения будут «тормозить» рекурсию. Это две решенные подзадачи.

```py
    memory = {1: 1, 2: 1}
```

В нашем словаре ключи – значения, которые будет принимать $N$, а значения к ключам – ячейки в таблице, которые по ходу выполнения функции будут заполняться. 

Теперь можно приступить к написанию функции, которая будет принимать на вход единственное число $N$. С самого начала нужно написать проверку, которая будет возвращать значение по ключу $N$, если такой ключ уже есть в словаре. Это условие также поможет не уйти в бесконечную рекурсию. Более подробное пояснение приведу ниже. 

```py
    memory = {1: 1, 2: 1}

    def fib(N):
        if N in memory:
            return memory[N]
```
 
Дальше мы опишем действия функции, если элемента по ключу $N$ в словаре нет. В этом случае нужно записать в словарь значение для ключа $N$, то есть `fib(N - 1) + fib(N - 2)`, и вернуть это значение. 

```py
    memory = {1: 1, 2: 1}

    def fib(N):
        if N in memory:
            return memory[N]
        else:
            memory[N] = fib(N - 1) + fib(N - 2)
            return memory[N]
```

Так почему эта функция вернет верный ответ? Если $N$ не равно $1$ или $2$, то начнет выполняться `else`, и функция будет искать значение для $N – 1$, затем для $N – 2$, $N – 3$ и так до тех пор, пока функция не «упрется» в изначально записанные решения для позадач. Тогда функция вернет 1 и поднимется на уровень выше – $F_3$ , для него запишет в словарь и вернет значение $F_1 + F_2 = 2$, поднимется еще на уровень выше и так далее, пока не найдется значение для $N – 1$. Затем функция сразу же вернет значение для $N – 2$, так как это значение уже было записано в словарь при подсчете `fib(N – 1)`.

Задача с поиском числа Фибоначчи довольно проста, поэтому ее решение несложно записать и без рекурсии:

```py
    memory = [0 for _ in range(N)]
    memory[0] = 1

    for i in range(1, N):
        memory[i] = memory[i - 1] + memory[i - 2]
        
    print(memory[N - 1])
```

В данном случае в качестве таблицы выступает массив длины $N$, а $N - 1$-ый элемент – $N$-ое число в ряду Фибоначчи (нумерация начинается с нуля). Достаточно задать первоначальное значение только нулевому элементу, так как в рамках этого решения второе число можно вывести по формуле (получится сумма нулевого элемента, который равен $1$, и $-1$-ого – последнего, который равен $0$). Так как нулевой элемент известен, $i$ будет принимать значения с 1 до $N – 1$, и $i$-му элементу в массиве будет присваиваться значение суммы $i – 1$-го и $i – 2$-го элементов. Обратиться к $N$-му числу Фибоначчи можно будет по индексу $N – 1$. 

Оба решения работают линейно, но в рекурсивном больше константа, поэтому на деле рекурсия работает медленнее цикла.
